module adder_8 (input [7:0] A, input [7:0] B, input Cin, output [7:0] Sum, output Cout);
    wire [7:0] carry;
    assign {carry[0], Sum[0]} = A[0] + B[0] + Cin;
    assign {carry[1], Sum[1]} = A[1] + B[1] + carry[0];
    assign {carry[2], Sum[2]} = A[2] + B[2] + carry[1];
    assign {carry[3], Sum[3]} = A[3] + B[3] + carry[2];
    assign {carry[4], Sum[4]} = A[4] + B[4] + carry[3];
    assign {carry[5], Sum[5]} = A[5] + B[5] + carry[4];
    assign {carry[6], Sum[6]} = A[6] + B[6] + carry[5];
    assign {Cout, Sum[7]} = A[7] + B[7] + carry[6];
endmodule

module and_8 (input [7:0] A, input [7:0] B, output [7:0] Out);
    and And_gate [7:0] (Out, A, B);
endmodule

module or_8 (input [7:0] A, input [7:0] B, output [7:0] Out);
    or Or_gate [7:0] (Out, A, B);
endmodule

module not_8 (input [7:0] A, output [7:0] Out);
    not Not_gate [7:0] (Out, A);
endmodule

module nand_8 (input [7:0] A, input [7:0] B, output [7:0] Out);
    nand Nand_gate [7:0] (Out, A, B);
endmodule

module rotate_left_8 (input [7:0] A, output [7:0] Out);
    assign Out = {A[6:0], A[7]};
endmodule

module rotate_right_8 (input [7:0] A, output [7:0] Out);
    assign Out = {A[0], A[7:1]};
endmodule

module left_shift_8 (input [7:0] A, output [7:0] Out);
    assign Out = A <<< 1;
endmodule

module right_shift_8 (input [7:0] A, output [7:0] Out);
    assign Out = A >>> 1;
endmodule

module mux_2x1(input [7:0] A, input [7:0] B, input Sel, output [7:0] Out);
    wire not_Sel;
    wire [7:0] Out_A, Out_B;
    assign not_Sel = ~Sel;
    and and1 [7:0] (Out_A, A, {8{not_Sel}});
    and and2 [7:0] (Out_B, B, {8{Sel}});
    or or1 [7:0] (Out, Out_A, Out_B);
endmodule

module mux_4x1(input [7:0] A, input [7:0] B, input [7:0] C, input [7:0] D, input [1:0] Sel, output [7:0] Out);
    wire [7:0] mux1_out, mux2_out;
    mux_2x1 mux1(.A(A), .B(B), .Sel(Sel[0]), .Out(mux1_out));
    mux_2x1 mux2(.A(C), .B(D), .Sel(Sel[0]), .Out(mux2_out));
    mux_2x1 mux3(.A(mux1_out), .B(mux2_out), .Sel(Sel[1]), .Out(Out));
endmodule

module mux_8x1(
    input [7:0] in0, in1, in2, in3, in4, in5, in6, in7, input [2:0] Sel, output [7:0] Out);
    wire [7:0] mux1_out, mux2_out;
    mux_4x1 mux1(.A(in0), .B(in1), .C(in2), .D(in3), .Sel(Sel[1:0]), .Out(mux1_out));
    mux_4x1 mux2(.A(in4), .B(in5), .C(in6), .D(in7), .Sel(Sel[1:0]), .Out(mux2_out));
    mux_2x1 mux3(.A(mux1_out), .B(mux2_out), .Sel(Sel[2]), .Out(Out));
endmodule

module mux_16x1(
    input [7:0] in0, in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, input [3:0] Sel, output [7:0] Out);
    wire [7:0] mux1_out, mux2_out;
    mux_8x1 mux1(.in0(in0), .in1(in1), .in2(in2), .in3(in3), .in4(in4), .in5(in5), .in6(in6), .in7(in7), .Sel(Sel[2:0]), .Out(mux1_out));
    mux_8x1 mux2(.in0(in8), .in1(in9), .in2(in10), .in3(in11), .in4(in12), .in5(in13), .in6(in14), .in7(in15), .Sel(Sel[2:0]), .Out(mux2_out));
    mux_2x1 mux3(.A(mux1_out), .B(mux2_out), .Sel(Sel[3]), .Out(Out));
endmodule

module ALU_8 (output [7:0] Result, output Zero, Negative, Overflow, input [7:0] A, B, input [3:0] AluOp);
    wire [7:0] A_in, B_in, add_res, seq_res ,eq_res, shl_res, shr_res, and_res, or_res, nand_res , not_res, rol_res, ror_res;
    wire of_add, overflow_signed;
    mux_2x1 muxA(.A(A), .B(~A), .Sel(AluOp[0]), .Out(A_in));
    mux_2x1 muxB(.A(B), .B(8'b00000001), .Sel(AluOp[1]), .Out(B_in));
    adder_8 general_adder(.A(A_in), .B(B_in), .Cin(AluOp[0]), .Sum(add_res), .Cout(of_add));
    mux_2x1 seq_mux(.A(8'b00000001), .B(8'b00000000), .Sel(|add_res), .Out(seq_res));
    left_shift_8 left_shift(.A(B), .Out(shl_res));
    right_shift_8 right_shift(.A(B), .Out(shr_res));
    rotate_left_8 left_rotate(.A(A), .Out(rol_res));
    rotate_right_8 right_rotate(.A(A), .Out(ror_res));
    not_8 my_not(.A(A), .Out(not_res));
    and_8 my_and(.A(A), .B(B), .Out(and_res));
    or_8 my_or(.A(A), .B(B), .Out(or_res));
    nand_8 nand_gate(.A(A), .B(B), .Out(nand_res));
    mux_16x1 alu_mux(
        .in0(add_res), .in1(add_res), .in2(add_res), .in3(8'b00000000),
        .in4(8'b00000000), .in5(seq_res), .in6(shl_res), .in7(shr_res),
        .in8(not_res), .in9(and_res), .in10(or_res), .in11(nand_res),
        .in12(rol_res), .in13(ror_res), .in14(8'b00000000), .in15(8'b00000000),
        .Sel(AluOp), .Out(Result)
    );
    assign overflow_signed =(A_in[7] & B_in[7] & ~add_res[7]) | (~A_in[7] & ~B_in[7] & add_res[7]);
    mux_2x1 overflow(.A(overflow_signed), .B(0), .Sel(AluOp[3] | AluOp[2]), .Out(Overflow));
    assign Zero = ~(|Result);
    mux_2x1 negative(.A(Result[7]), .B(0), .Sel(AluOp[3]), .Out(Negative));
endmodule

module tb_ALU_selfcheck();
    reg [7:0] A, B;
    reg [3:0]  ALUOp;
    wire [7:0] Result;
    wire Zero, Negative, Overflow;

    integer pass_count = 0;
    integer fail_count = 0;
    integer total = 0;
    reg [7:0] expected;
    reg exp_zero, exp_neg, exp_ovf;

    // Instantiate the ALU
    ALU_8 inst (.Result(Result),.Zero(Zero),.Negative(Negative),.Overflow(Overflow),.A(A), .B(B),.AluOp(ALUOp) );

    task check;
        input [3:0] op;
        input [7:0] a, b, exp;
        input expZ, expN, expO;
        begin
            ALUOp = op; A = a; B = b;
            #5; // wait for output to settle
            total = total + 1;
            if (Result === exp && Zero === expZ && Negative === expN && Overflow === expO) begin
                pass_count = pass_count + 1;
                $display("PASS @ time=%0t | ALUOp=%b | A=%b | B=%b | res=%b | Exp=%b | Zero=%b | Neg=%b | Ovf=%b",
                        $time, ALUOp, A, B, Result, exp, Zero, Negative, Overflow);
            end
            else begin
                fail_count = fail_count + 1;
                $display("FAIL @ time=%0t | ALUOp=%b | A=%b | B=%b | res=%b | Exp=%b | Zero=%b (Exp %b) | Neg=%b (Exp %b) | Ovf=%b (Exp %b)",
                        $time, ALUOp, A, B, Result, exp, Zero, expZ, Negative, expN, Overflow, expO);
            end
        end
    endtask

    initial begin
    $display("----- Starting ALU Self-Checking Testbench -----");

    // ADD (0000) A+B
    check(4'b0000, 10, 5, 15, 0, 0, 0);
    check(4'b0000, 0, 0, 0, 1, 0, 0);
    check(4'b0000, 255, 1, 0, 1, 0, 0);
    check(4'b0000, 127, 1, 128, 0, 1, 1); // Overflow case

    // SUB (0001) B-A
    check(4'b0001, 5, 10, 5, 0, 0, 0);
    check(4'b0001, 10, 5, 251, 0, 1, 0);
    check(4'b0001, 0, 0, 0, 1, 0, 0);
    check(4'b0001, 128, 1, 129, 0, 1, 1); // Overflow case

    // increment (0010) A+1
    check(4'b0010, 5, 0, 6, 0, 0, 0);
    check(4'b0010, 255, 0, 0, 1, 0, 0);
    check(4'b0010, 127, 0, 128, 0, 1, 1); // Overflow case

    // SEQ (0101) A==B
    check(4'b0101, 5, 5, 1, 0, 0, 0);
    check(4'b0101, 5, 10, 0, 1, 0, 0);
    check(4'b0101, 0, 0, 1, 0, 0, 0);
    check(4'b0101, 255, 0, 0, 1, 0, 0);

    // Left Shift (0110) B <<< 1
    check(4'b0110, 0, 5, 10, 0, 0, 0);
    check(4'b0110, 0, 128, 0, 1, 0, 0);
    check(4'b0110, 0, 255, 254, 0, 1, 0);
    check(4'b0110, 0, 0, 0, 1, 0, 0);

    // Right Shift (0111) B >>> 1
    check(4'b0111, 0, 10, 5, 0, 0, 0);
    check(4'b0111, 0, 1, 0, 1, 0, 0);
    check(4'b0111, 0, 255, 127, 0, 0, 0);
    check(4'b0111, 0, 0, 0, 1, 0, 0);

    // NOT (1000) ~A
    check(4'b1000, 5, 0, 250, 0, 0, 0);
    check(4'b1000, 0, 0, 255, 0, 0, 0);
    check(4'b1000, 255, 0, 0, 1, 0, 0);
    check(4'b1000, 170, 0, 85, 0, 0, 0);

    // AND (1001) A & B
    check(4'b1001, 5, 3, 1, 0, 0, 0);
    check(4'b1001, 255, 0, 0, 1, 0, 0);
    check(4'b1001, 170, 85, 0, 1, 0, 0);
    check(4'b1001, 15, 15, 15, 0, 0, 0);

    // OR (1010) A | B
    check(4'b1010, 5, 3, 7, 0, 0, 0);
    check(4'b1010, 0, 0, 0, 1, 0, 0);
    check(4'b1010, 170, 85, 255, 0, 0, 0);
    check(4'b1010, 15, 0, 15, 0, 0, 0);

    // NAND (1011) ~(A & B)
    check(4'b1011, 5, 3, 254, 0, 0, 0);
    check(4'b1011, 255, 0, 255, 0, 0, 0);
    check(4'b1011, 170, 85, 255, 0, 0, 0);
    check(4'b1011, 15, 15, 240, 0, 0, 0);

    // Rotate Left (1100) A rol 1
    check(4'b1100, 130, 0, 5, 0, 0, 0);
    check(4'b1100, 255, 0, 255, 0, 0, 0);
    check(4'b1100, 1, 0, 2, 0, 0, 0);
    check(4'b1100, 0, 0, 0, 1, 0, 0);

    // Rotate Right (1101) A ror 1
    check(4'b1101, 5, 0, 130, 0, 0, 0);
    check(4'b1101, 255, 0, 255, 0, 0, 0);
    check(4'b1101, 2, 0, 1, 0, 0, 0);
    check(4'b1101, 0, 0, 0, 1, 0, 0);
    
    $display("------------------------------------------------");
    $display("Tests Completed: %0d total | %0d passed | %0d failed", total, pass_count, fail_count);
    $display("------------------------------------------------");

    if (fail_count == 0)
        $display("All ALU tests passed successfully!");
    else
        $display("Some tests failed! Please review details above.");

    $finish;
    end
endmodule

module main;
    tb_ALU_selfcheck tb();
endmodule